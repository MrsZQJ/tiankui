// Generated by CoffeeScript 1.10.0
var Game, game;

Game = (function() {
  function Game() {
    this.start();
  }

  Game.prototype.start = function() {
    var i, j, k, l, o, q;
    if (localStorage && localStorage.getItem('tiles')) {
      this.score = parseInt(localStorage.getItem('score'));
      this.tiles = JSON.parse(localStorage.getItem('tiles'));
      $('.score').text(this.score);
      $('.score-best').text(localStorage.getItem('bestScore'));
      for (i = k = 0; k < 4; i = ++k) {
        for (j = l = 0; l < 4; j = ++l) {
          this.addTile(i, j, this.tiles[i][j]);
        }
      }
    } else {
      $('.score').text(0);
      if (localStorage.getItem('bestScore')) {
        $('.score-best').text(localStorage.getItem('bestScore'));
      }
      $('.tile').remove();
      this.score = 0;
      this.over = false;
      this.tiles = [];
      for (i = o = 0; o < 4; i = ++o) {
        this.tiles[i] = [];
        for (j = q = 0; q < 4; j = ++q) {
          this.tiles[i][j] = 0;
        }
      }
      this.generateTile();
      this.generateTile();
    }
  };

  Game.prototype.getEnableTiles = function() {
    var enableTiles, i, j, k, l;
    enableTiles = [];
    for (i = k = 0; k < 4; i = ++k) {
      for (j = l = 0; l < 4; j = ++l) {
        if (this.tiles[i][j] === 0) {
          enableTiles.push({
            x: i,
            y: j
          });
        }
      }
    }
    return enableTiles;
  };

  Game.prototype.addTile = function(i, j, value) {
    var tileText;
    if (value) {
      tileText = "<div class='tile tile-" + value + " tile-pos-" + i + "-" + j + " tile-new'><div class='tile-inner'>" + value + "</div></div>";
      return $('.tile-container').append(tileText);
    }
  };

  Game.prototype.generateTile = function() {
    var enableTiles, len, tile;
    enableTiles = this.getEnableTiles();
    len = enableTiles.length;
    tile = enableTiles[Math.floor(Math.random() * len)];
    this.tiles[tile.x][tile.y] = 2;
    this.addTile(tile.x, tile.y, 2);
  };

  Game.prototype.findTile = function(tile, vertex) {
    var merge, pre_x, pre_y, ref, ref1, to, x, y;
    merge = 0;
    x = tile.x, y = tile.y;
    while (true) {
      ref = [x, y], pre_x = ref[0], pre_y = ref[1];
      ref1 = [pre_x + vertex.x, pre_y + vertex.y], x = ref1[0], y = ref1[1];
      if (!(x < 4 && x >= 0 && y < 4 && y >= 0 && this.tiles[x][y] === 0)) {
        break;
      }
    }
    to = {
      x: pre_x,
      y: pre_y
    };
    if (x < 4 && x >= 0 && y < 4 && y >= 0 && this.tiles[x][y] === this.tiles[tile.x][tile.y] && this.used[x][y] === 0) {
      merge = this.tiles[x][y];
      to = {
        x: x,
        y: y
      };
      this.used[x][y] = 1;
    }
    return {
      to: to,
      merge: merge
    };
  };

  Game.prototype.moveSingleTile = function(tile, vertex) {
    var isMove, merge, ref, score_add, to;
    isMove = false;
    score_add = 0;
    ref = this.findTile(tile, vertex), to = ref.to, merge = ref.merge;
    if (tile.x !== to.x || tile.y !== to.y) {
      this.moveTileAct(tile, to, merge);
      isMove = true;
    }
    return {
      isMove: isMove,
      score_add: merge
    };
  };

  Game.prototype.moveTileAct = function(fromTile, toTile, merge) {
    var i, j, m, n, p;
    m = toTile.x, n = toTile.y;
    i = fromTile.x, j = fromTile.y;
    this.tiles[m][n] = this.tiles[i][j];
    this.tiles[i][j] = 0;
    p = $(".tile-pos-" + i + "-" + j);
    if (merge) {
      this.tiles[m][n] = merge * 2;
      $(".tile-pos-" + m + "-" + n).remove();
      p.addClass("tile-merge tile-" + this.tiles[m][n]);
      $('.tile-inner', p).text(this.tiles[m][n]);
    }
    return p.removeClass("tile-pos-" + i + "-" + j).addClass("tile-pos-" + m + "-" + n);
  };

  Game.prototype.moveVertex = function(vertex) {
    var canMove, grids, i, isMove, j, k, l, len1, len2, o, q, r, ref, ref1, ref2, score_add, score_sum;
    canMove = false;
    score_sum = 0;
    grids = {
      x: [],
      y: []
    };
    for (i = k = 0; k < 4; i = ++k) {
      grids.x.push(i);
      grids.y.push(i);
    }
    if (vertex.y === 1) {
      grids.y.reverse();
    }
    if (vertex.x === 1) {
      grids.x.reverse();
    }
    this.used = [];
    for (i = l = 0; l < 4; i = ++l) {
      this.used[i] = [];
      for (j = o = 0; o < 4; j = ++o) {
        this.used[i][j] = 0;
      }
    }
    ref = grids.x;
    for (q = 0, len1 = ref.length; q < len1; q++) {
      i = ref[q];
      ref1 = grids.y;
      for (r = 0, len2 = ref1.length; r < len2; r++) {
        j = ref1[r];
        if (this.tiles[i][j] !== 0) {
          ref2 = this.moveSingleTile({
            x: i,
            y: j
          }, vertex), isMove = ref2.isMove, score_add = ref2.score_add;
          canMove = canMove || isMove;
          score_sum = score_add + score_sum;
        }
      }
    }
    return {
      score_sum: score_sum,
      canMove: canMove
    };
  };

  Game.prototype.move = function(keyCode) {
    var self, vertex, vertexs;
    vertexs = [
      {
        x: 0,
        y: -1
      }, {
        x: -1,
        y: 0
      }, {
        x: 0,
        y: 1
      }, {
        x: 1,
        y: 0
      }
    ];
    switch (keyCode) {
      case 37:
        vertex = vertexs[0];
        break;
      case 38:
        vertex = vertexs[1];
        break;
      case 39:
        vertex = vertexs[2];
        break;
      case 40:
        vertex = vertexs[3];
    }
    self = this;
    window.requestAnimationFrame(function() {
      var canMove, ref, score_sum;
      ref = self.moveVertex(vertex), score_sum = ref.score_sum, canMove = ref.canMove;
      if (canMove) {
        self.generateTile();
        if (score_sum) {
          self.updateScore(score_sum);
        }
      } else {
        self.isGameover();
      }
      localStorage.setItem('tiles', JSON.stringify(self.tiles));
    });
  };

  Game.prototype.updateScore = function(score_add) {
    this.score = this.score + score_add;
    $('.score-count').text(this.score);
    $('.score-add').remove();
    $('.score-panel').append('<div class="score-add"></div>');
    $('.score-add').text("+" + score_add);
    localStorage.setItem('score', this.score);
    if (this.score > localStorage.getItem('bestScore')) {
      localStorage.setItem('bestScore', this.score);
      $('.score-best').text(this.score);
    }
  };

  Game.prototype.isGameover = function() {
    var i, j, k, l, len;
    len = this.getEnableTiles().length;
    if (len !== 0) {
      return;
    }
    for (i = k = 0; k < 4; i = ++k) {
      for (j = l = 0; l < 4; j = ++l) {
        if ((j < 3 && this.tiles[i][j] === this.tiles[i][j + 1]) || (i < 3 && this.tiles[i][j] === this.tiles[i + 1][j])) {
          return;
        }
      }
    }
    $('.over-container').addClass('active');
    this.over = true;
  };

  return Game;

})();

game = new Game();

$(document).on('keydown', function(event) {
  var ref;
  event.preventDefault();
  if (!game.over && ((ref = event.keyCode) === 37 || ref === 38 || ref === 39 || ref === 40)) {
    game.move(event.keyCode);
  }
});

$('.start').on('click', function(event) {
  $('.over-container').removeClass('active');
  localStorage.removeItem('score');
  localStorage.removeItem('tiles');
  game.start();
});

//# sourceMappingURL=main.js.map
